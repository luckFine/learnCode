<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>
    // Array.prototype.map = function (callbackFn, thisArg) {
    //     // 处理数组类型异常
    //     if (this === null || this === undefined) {
    //         throw new TypeError('Cannot read property "map" of null or undefined')
    //     }
    //     // 处理回调类型异常
    //     if (Object.prototype.toString.call(callbackFn) != "[object Function]") {
    //         throw new TypeError(callbackFn + ' is not a function')
    //     }
    //     // 草案中提到要先转换为对象
    //     let O = Object(this); // [1,2,3]
    //     let T = thisArg;
    //     let len = O.length >>> 0;
    //     // 创建一个与参数数组个数一样的数组
    //     let A = new Array(len);
    //     for (let k = 0; k < len; k++) {
    //         // 还记得原型链那一节提到的 in 吗？in 表示在原型链查找
    //         // 如果用 hasOwnProperty 是有问题的，它只能找私有属性
    //         if (k in O) {
    //             let kValue = O[k];
    //             // 依次传入this, 当前项，当前索引，整个数组
    //             let mappedValue = callbackFn.call(T, kValue, k, O);
    //             A[k] = mappedValue;
    //         }
    //     }
    //     return A;
    // }
    // function Foo() {
    //     getName = function () { alert(1); };
    //     return this;
    // }
    // Foo.getName = function () { alert(2); };
    // Foo.prototype.getName = function () { alert(3); };
    // var getName = function () { alert(4); };
    // function getName() { alert(5); }

    // //请写出以下输出结果：
    // Foo.getName();
    // getName();
    // Foo().getName();
    // getName();
    // new Foo.getName();
    // new Foo().getName();
    // new new Foo().getName();

    // const someone = {
    //     name:'luckfine',
    //     stars:'zs',
    //     money:0
    // }
    // let obj = new Proxy(someone, {
    //     get: function (target, propKey, receiver) {
    //         console.log(`getting ${propKey}!`);
    //         return Reflect.get(target, propKey, receiver);
    //     },
    //     set: function (target, propKey, value, receiver) {
    //         console.log(`setting ${propKey}!`);
    //         return Reflect.set(target, propKey, value, receiver);
    //     }
    // });
    // obj.money++
    // // getting money!
    // // setting money!
    // console.log(obj.money)
    // getting money!
    // 1

    // let obj = new Proxy({}, {
    //     // 拦截对象属性的读取,比如proxy.foo和proxy['foo']
    //     get: function (target, propKey, receiver) {
    //         console.log('sonme code ....')
    //     },
    //     // 拦截对象属性的设置，比如proxy.foo = v或proxy['foo'] = v，返回一个布尔值
    //     set: function (target, propKey, value, receiver) {
    //         console.log('sonme code ....')
    //     },
    //     // 拦截propKey in proxy的操作，返回一个布尔值
    //     has: function (target, propKey, receiver) {
    //         console.log('sonme code ....')
    //     },
    //     // 拦截delete proxy[propKey]的操作，返回一个布尔值。
    //     deleteProperty: function (target, propKey) {
    //         console.log('sonme code ....')
    //     },
    //     // 拦截Object.getOwnPropertyNames(proxy)、Object.getOwnPropertySymbols(proxy)、Object.keys(proxy)、for...in循环，
    //     // 返回一个数组。该方法返回目标对象所有自身的属性的属性名，
    //     // 而Object.keys()的返回结果仅包括目标对象自身的可遍历属性。
    //     ownKeys:function(target){
    //         console.log('sonme code ....')
    //     },
    //     // 拦截Object.getOwnPropertyDescriptor(proxy, propKey)，返回属性的描述对象
    //     getOwnPropertyDescriptor: function (target, propKey) {
    //         console.log('sonme code ....')
    //     },
    //     // 拦截Object.defineProperty(proxy, propKey, propDesc）、Object.defineProperties(proxy, propDescs)，返回一个布尔值。
    //     defineProperty: function (target, propKey, propDesc) {
    //         console.log('sonme code ....')
    //     },
    //     // 拦截Object.preventExtensions(proxy)，返回一个布尔值。
    //     preventExtensions: function (target) {
    //         console.log('sonme code ....')
    //     },
    //     // 拦截Object.getPrototypeOf(proxy)，返回一个对象
    //     getPrototypeOf: function (target) {
    //         console.log('sonme code ....')
    //     },
    //     // 拦截Object.isExtensible(proxy)，返回一个布尔值。
    //     isExtensible: function (target) {
    //         console.log('sonme code ....')
    //     },
    //     // 拦截Object.setPrototypeOf(proxy, proto)，返回一个布尔值。
    //     // 如果目标对象是函数，那么还有两种额外操作可以拦截。
    //     setPrototypeOf: function (target, proto) {
    //         console.log('sonme code ....')
    //     },
    //     // 拦截 Proxy 实例作为函数调用的操作，比如proxy(...args)、
    //     // proxy.call(object, ...args)、proxy.apply(...)。
    //     apply: function (target, object, args) {
    //         console.log('sonme code ....')
    //     },
    //     // 拦截 Proxy 实例作为构造函数调用的操作，比如new proxy(...args)。
    //     construct:function (target, args) {

    //     }
    // });


    // const dom = new Proxy({}, {
    //     get(target, property) {
    //         return function (attrs = {}, ...children) {
    //             const el = document.createElement(property);
    //             for (let prop of Object.keys(attrs)) {
    //                 el.setAttribute(prop, attrs[prop]);
    //             }
    //             for (let child of children) {
    //                 if (typeof child === 'string') {
    //                     child = document.createTextNode(child);
    //                 }
    //                 el.appendChild(child);
    //             }
    //             return el;
    //         }
    //     }
    // });

    // const el = dom.div({},
    //     'Hello, my name is ',
    //     dom.a({ href: '//example.com' }, 'Mark'),
    //     '. I like:',
    //     dom.ul({},
    //         dom.li({}, 'The web'),
    //         dom.li({}, 'Food'),
    //         dom.li({}, '…actually that\'s it')
    //     )
    // );

    // document.body.appendChild(el);
    

// 

// let obj = {
//     name:'luck'
// }
// const { age } = obj

// console.log(age,obj)

    var arr = [2, 12, 5, 3, 78, 46, 96, 67, 23]
    // function bubbleSort(arr) {
    //     for (var i = 0; i < arr.length - 1; i++) {
    //         for (var j = 0; j < arr.length - 1 - i; j++) {
    //             if (arr[j] >= arr[j + 1]) {
    //                 [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]]
    //             }
    //         }
    //     }

    //     return arr;
    // }
    // console.log(bubbleSort(arr)) 
    // function selectionSort(arr){
    //     let min 
    //     let temp
    //     for (let j = 0; j < arr.length - 1; j++) {
    //         min = j;
    //         // 应该把最小值和j进行交换
    //         for(let i = j + 1; i < arr.length-1 ; i++){
    //             if(arr[min] > arr[i]){
    //                 min = i
    //                 temp = arr[j]
    //                 arr[j] = arr[i]
    //                 arr[i] = temp
    //             }
    //         }    
    //     }
    //     return arr
    // }
    // console.log(selectionSort(arr))

    // function insertionSort(array) {
    //     // 获取数组的长度
    //     var length = array.length

    //     for(let i = 1 ; i < length ; i++){
    //         let temp = array[i]
    //         let j = i
    //         while (arr[j-1] >= temp && j > 0) {
    //             arr[j] = array[j-1]
    //             j--
    //         }
    //         arr[j] = temp
    //     }
    //     return array;
    // }
    // console.log(insertionSort(arr)) 

    function shellSort(array) {
        //1.获取数组的长度
        let length = array.length
        //2.初始化增量
        let gap = Math.floor(length / 2)
        //3.第一层循环：while循环(使gap不断减小)
        while (gap >= 1) {
            //4.第二层循环：以gap为增量，进行分组，对分组进行插入排序
            //重点为：将index = gap作为选中的第一个数据
            for (let i = gap; i < length; i = i+gap) {
                let temp = array[i]
                let j = i
                //5.第三层循环:寻找正确的插入位置
                while (array[j - gap] > temp && j > gap - 1) {
                    array[j] = array[j - gap]
                    j -= gap
                }
                //6.将j位置的元素设置为temp
                array[j] = temp
            }
            gap = Math.floor(gap / 2)
        }
        return array
    }
        console.log(arr)
        console.log(shellSort(arr))
</script>
</body>
</html>